/*
 * host_provision.c
 *
 * Created: 3/28/2016 9:52:02 AM
 *  Author: oscar.sanchez
 */ 
#include <asf.h>
#include <stdio.h>
#include "main.h"
#include "provisioning.h"
#include "cryptoauthlib.h"
#include "basic/atca_basic.h"



//HOST Provisioning Array
static const uint8_t host_config_zone[88] = {
  0x01, 0x23, 0x00, 0x00,
  0x00, 0x08, 0x03, 0x00,
  0x04, 0x05, 0x06, 0x07,
  0xEE, 0x0D, 0x0E, 0x0F,
  0xCE,       //I2C Address for ECC508
  0xFF, 0x55, 0x00,
  0x90, 0x80, //Slot 0-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
  0x80, 0x80, //Slot 1-> IS SECRET / NEVER WRITE
  0x90, 0x80, //Slot 2-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
  0x90, 0x80, //Slot 3-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
  0x80, 0x4E, //Slot 4-> NO READ / ENCRYPTED WRITE
  0x80, 0x4E, //Slot 5-> NO READ / ENCRYPTED WRITE
  0x00, 0x4E, //Slot 6-> CLEAR READ / ENCRYPTED WRITE
  0x80, 0x4E, //Slot 7-> NO READ / ENCRYPTED WRITE
  0x00, 0x4E, //Slot 8-> CLEAR READ / ENCRYPTED WRITE
  0x00, 0x4E, //Slot 9-> CLEAR READ / ENCRYPTED WRITE
  0x00, 0x4E, //Slot A-> CLEAR READ / ENCRYPTED WRITE
  0x00, 0x4E, //Slot B-> CLEAR READ / ENCRYPTED WRITE
  0x00, 0x4E, //Slot C-> CLEAR READ / ENCRYPTED WRITE
  0x00, 0x4E, //Slot D-> CLEAR READ / ENCRYPTED WRITE
  0x80, 0x80, //Slot E-> NO READ, NO CHECKMAC COPY / NEVER WRITE
  0x90, 0x80, //Slot F-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
  0xFF, 0x00, 0xFF, 0x00,
  0xFF, 0x00, 0xFF, 0x00,
  0xFF, 0x00, 0xFF, 0x00,
  0xFF, 0x00, 0xFF, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x00, 0x55, 0x55 };

static const uint8_t host_data_zone[512] =
{
  //Slot 0 / Key 0
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
  //Slot 1 / Key 1
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
  //Slot 2 / Key 2
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  //slot 3 / Key 3
  0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
  0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
  //slot 4 / Key 4
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot 5 / Key 5
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot 6 / Key 6
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot 7 / Key 7
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot 8 / Key 8
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot 9 / Key 9
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot A / Key A
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot B / Key B
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot C / Key C
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot D / Key D
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  //slot E / Key E
  0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
  0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
  //slot F / Key F
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};


//CLIENT Provisioning Array
static const uint8_t client_config_zone[88] = {
	0x01, 0x23, 0x00, 0x00,
	0x00, 0x08, 0x03, 0x00,
	0x04, 0x05, 0x06, 0x07,
	0xEE, 0x0D, 0x0E, 0x0F,
	0xC8,       //I2C Address for ECC508
	0xFF, 0x55, 0x00,
	0x90, 0x80, //Slot 0-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
	0x80, 0x80, //Slot 1-> IS SECRET / NEVER WRITE
	0x90, 0x80, //Slot 2-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
	0x90, 0x80, //Slot 3-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
	0x80, 0x4E, //Slot 4-> NO READ / ENCRYPTED WRITE
	0x80, 0x4E, //Slot 5-> NO READ / ENCRYPTED WRITE
	0x00, 0x4E, //Slot 6-> CLEAR READ / ENCRYPTED WRITE
	0xAF, 0x3F, //Slot 7-> NO READ, SINGLE USE / DERIVE KEY
	0x00, 0x4E, //Slot 8-> CLEAR READ / ENCRYPTED WRITE
	0x00, 0x4E, //Slot 9-> CLEAR READ / ENCRYPTED WRITE
	0x00, 0x4E, //Slot A-> CLEAR READ / ENCRYPTED WRITE
	0x00, 0x4E, //Slot B-> CLEAR READ / ENCRYPTED WRITE
	0x00, 0x4E, //Slot C-> CLEAR READ / ENCRYPTED WRITE
	0x00, 0x4E, //Slot D-> CLEAR READ / ENCRYPTED WRITE
	0x80, 0x80, //Slot E-> NO READ, NO CHECKMAC COPY / NEVER WRITE
	0xB0, 0x80, //Slot F-> NO READ, CHECK ONLY, NO CHECKMAC COPY / NEVER WRITE
	0xFF, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x00, 0x55, 0x55 };

uint8_t client_data_zone[512] =
{
	//Slot 0 / Key 0
	0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
	//Slot 1 / Key 1 ****Derive Key. Generate Derive Key Using ACES. Having as Host Parent Slot 0 and as Key 1.Paste here******
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//Slot 2 / Key 2
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
	//slot 3 / Key 3
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	//slot 4 / Key 4
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot 5 / Key 5
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot 6 / Key 6
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot 7 / Key 7 ****Derive Key Consumtion Counting. Generate Derive Key Using ACES. Having as Host Parent Slot F and as Key 7.Paste here******
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot 8 / Key 8
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot 9 / Key 9
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot A / Key A
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot B / Key B
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot C / Key C
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot D / Key D
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//slot E / Key E
	0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
	0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
	//slot F / Key F
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/*Structure used to generate the DeriveKey that will be stored in the Client device*/
struct client_derive_key_t	client_derive_key = {
	.root_key = {0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00},
	.op_code = {0x1C},
	.mode = {0x04},
	.param = {0x01, 0x00},
	.serial_8 = {0xEE},
	.serial_0_1 = {0x01, 0x23},
	.zeros = {0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00},
};

int host_provision(void)
{
  static int ret = 0;
  bool lockstate = 0;
  uint8_t lock_response;
  char disp_str[1700];
  int disp_size = sizeof(disp_str);
  uint8_t ecc508_info[4] = {};
  
  cfg_sha204a_i2c_default.atcai2c.slave_address = DERIVED_KEY_HOST_I2C_ADDR;
  ret = atcab_init( &cfg_sha204a_i2c_default );
  ret = atcab_info(ecc508_info);
  if (ret != ATCA_SUCCESS)
  {
	  cfg_sha204a_i2c_default.atcai2c.slave_address = ATSHA204_FACTORY_I2C_ADDR;
	  ret = atcab_init( &cfg_sha204a_i2c_default );
  }
  
  //CHECK IF THE CONFIG ZONE IS LOCKED
  ret = atcab_is_locked(LOCK_ZONE_CONFIG, &lockstate);
  //IF ITS LOCKED, THERES NOTHING TO DO, RETURN
  if (ret != ATCA_SUCCESS) return ret;
  if (!lockstate)
  {
    //IF ITS NOT LOCKED THEN WRITE CONFIGURATION
    ret = atcab_write_sha_config_zone(host_config_zone);
    if (ret != ATCA_SUCCESS) return ret;
    else
    {
      disp_size = sizeof(disp_str);
      atcab_bin2hex(host_config_zone, sizeof(host_config_zone), disp_str, &disp_size);
      printf("Writing SHA204 Configuration Zone:\r\n%s\r\n", disp_str);
    }
    //AFTER SUCCESSFULL WRITING LOCK ZONE
    ret = atcab_lock_config_zone(&lock_response);
    if (ret != ATCA_SUCCESS) return ret;
  }
  else
  {
    printf("\n\rConfiguratioin Zone Locked\n");
  }
  //PLACE SHA204 IN SLEEP MODE
  atcab_sleep();
  
  //CHECK IF DATA ZONE (WHERE KEYS ARE STORED), IS LOCKED
  ret = atcab_is_locked(LOCK_ZONE_DATA, &lockstate);
   //IF ITS LOCKED, THERES NOTHING TO DO, RETURN
  if (ret != ATCA_SUCCESS) return ret;
  if (!lockstate)
  {
    //IF ITS NOT LOCKED THEN WRITE DATA (KEYS)
    ret = host_write_data_zone(host_data_zone, sizeof(host_data_zone));
    if (ret != ATCA_SUCCESS) return ret;
    else
    {
      printf("\r\nTHESE KEY VALUES ARE SHOWN ONLY FOR DEMOSTRATION PURPOSES!");
      printf("\r\nAND SHOULD BE KEPT SECRET!\r\n");
      disp_size = sizeof(disp_str);
      atcab_bin2hex(host_data_zone, sizeof(host_data_zone), disp_str, &disp_size);
      printf("Writing SHA204 Configuration Zone:\r\n%s\r\n", disp_str);
    }
    //AFTER SUCCESSFULL WRITING LOCK DATA ZONE
    ret = atcab_lock_data_zone(&lock_response);
    if (ret != ATCA_SUCCESS) return ret;
  }
  else
  {
    printf("\n\rData Zone Locked\n\r");
  }
  
  atcab_sleep();
  return ret;
}

int host_write_data_zone(const uint8_t * data, uint16_t len)
{
  uint8_t ret = ATCA_SUCCESS;
  int index = 0;
  uint8_t slot = 0;
  
  do
  {
    atcab_idle();
	ret = atcab_write_bytes_zone(ATCA_ZONE_DATA, slot, 0, &data[index], 32);
    if (ret != ATCA_SUCCESS)
    {
      asm("nop");
      break;
    }
    index += 32;
    slot++;
  } while (index < len);
  
  return ret;
}

int client_provision(void)
{
	static int ret = 0;
	bool lockstate = 0;
	uint8_t lock_response;
	char disp_str[1700];
	int disp_size = sizeof(disp_str);
	uint8_t derive_key_1[32];
	uint8_t derive_key_2[32];
	
	
	uint8_t root_key_non_consumption_cout[32] = {0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
	                                             0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00};
	
	uint8_t root_key_consuption_count[32] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	                                         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
	
	
	cfg_sha204a_i2c_default.atcai2c.slave_address = ATSHA204_FACTORY_I2C_ADDR;
	ret = atcab_init( &cfg_sha204a_i2c_default );
	
	ret = generate_derive_key(derive_key_1, 0x01, root_key_non_consumption_cout);
	if (ret != ATCA_SUCCESS) return ret;
	
	/*Writing Derive Key into Buffer, to be written to Client Sha204 Data Zone Slot 1*/
	memcpy(&client_data_zone[32 * 1], derive_key_1, 32);
	
	ret = generate_derive_key(derive_key_2, 0x07, root_key_consuption_count);
	/*Writing Derive Key into Buffer, to be written to Client Sha204 Data Zone Slot 1*/
	memcpy(&client_data_zone[32 * 7], derive_key_2, 32);
	
	disp_size = sizeof(disp_str);
	atcab_bin2hex(derive_key_1, sizeof(derive_key_1), disp_str, &disp_size);
	printf("Derive Key no consumption counting:\r\n%s\r\n", disp_str);
	
	disp_size = sizeof(disp_str);
	atcab_bin2hex(derive_key_2, sizeof(derive_key_2), disp_str, &disp_size);
	printf("Derive Key consumption counting:\r\n%s\r\n", disp_str);
	
	asm("nop");
	
	//CHECK IF THE CONFIG ZONE IS LOCKED
	ret = atcab_is_locked(LOCK_ZONE_CONFIG, &lockstate);
	//IF ITS LOCKED, THERES NOTHING TO DO, RETURN
	if (ret != ATCA_SUCCESS) return ret;
	if (!lockstate)
	{
		//IF ITS NOT LOCKED THEN WRITE CONFIGURATION
		ret = atcab_write_sha_config_zone(client_config_zone);
		if (ret != ATCA_SUCCESS) return ret;
		else
		{
			disp_size = sizeof(disp_str);
			atcab_bin2hex(client_config_zone, sizeof(client_config_zone), disp_str, &disp_size);
			printf("Writing SHA204 Configuration Zone:\r\n%s\r\n", disp_str);
		}
		//AFTER SUCCESSFULL WRITING LOCK ZONE
		ret = atcab_lock_config_zone(&lock_response);
		if (ret != ATCA_SUCCESS) return ret;
	}
	else
	{
		printf("\n\rConfiguratioin Zone Locked\n");
	}
	//PLACE SHA204 IN SLEEP MODE
	atcab_sleep();
	
	//After Sleep I2C address change will take effect and now we need to update the library with the new address
	cfg_sha204a_i2c_default.atcai2c.slave_address = DERIVED_KEY_CLIENT_I2C_ADDR;
	atcab_init( &cfg_sha204a_i2c_default );
	
	//CHECK IF DATA ZONE (WHERE KEYS ARE STORED), IS LOCKED
	ret = atcab_is_locked(LOCK_ZONE_DATA, &lockstate);
	//IF ITS LOCKED, THERES NOTHING TO DO, RETURN
	if (ret != ATCA_SUCCESS) return ret;
	if (!lockstate)
	{
		//IF ITS NOT LOCKED THEN WRITE DATA (KEYS)
		ret = client_write_data_zone(client_data_zone, sizeof(client_data_zone));
		if (ret != ATCA_SUCCESS) return ret;
		else
		{
			printf("\r\nTHESE KEY VALUES ARE SHOWN ONLY FOR DEMOSTRATION PURPOSES!");
			printf("\r\nAND SHOULD BE KEPT SECRET!\r\n");
			disp_size = sizeof(disp_str);
			atcab_bin2hex(client_data_zone, sizeof(client_data_zone), disp_str, &disp_size);
			printf("Writing SHA204 Configuration Zone:\r\n%s\r\n", disp_str);
		}
		//AFTER SUCCESSFULL WRITING LOCK DATA ZONE
		ret = atcab_lock_data_zone(&lock_response);
		if (ret != ATCA_SUCCESS) return ret;
	}
	else
	{
		printf("\n\rData Zone Locked\n\r");
	}
	return ret;
}

int client_write_data_zone(const uint8_t * data, uint16_t len)
{
	int ret = ATCA_SUCCESS;
	int index = 0;
	uint8_t slot = 0;
	
	do
	{
		atcab_idle();
		ret = atcab_write_bytes_zone(ATCA_ZONE_DATA, slot, 0, &data[index], 32);
		if (ret != ATCA_SUCCESS)
		{
			asm("nop");
			break;
		}
		index += 32;
		slot++;
		
	} while (index < len);
	
	return ret;
}

int generate_derive_key(uint8_t * derive_key, uint8_t derive_slot, uint8_t * root_key)
{
	char disp_str[1500];
	int disp_size = sizeof(disp_str);
	uint8_t return_code = ATCA_SUCCESS;
	atcac_sha2_256_ctx ctx;
	
	printf("Generating Derive Key\r\n");
	printf("Communicating with Client to obtain Serial Number\r\n");
	
	/*Setting the Derive Key Slot to be used*/
	client_derive_key.param[0] = derive_slot;
	memcpy(client_derive_key.root_key, root_key, 32);
	
	do{
		///*CLIENT Read Serial Number*/
		return_code = atcab_read_serial_number(client_derive_key.temp_key);
		if (return_code != ATCA_SUCCESS)
		{
			printf("Read Serial Number failed\r\n");
			break;
		}else
		{
			disp_size = sizeof(disp_str);
			atcab_bin2hex( client_derive_key.temp_key , 9, disp_str, &disp_size);
			printf("Client Serial Number:\n\r\n%s\r\n", disp_str);
			
			/*Padding Client's Serial number with 0x77*/
			memset(&client_derive_key.temp_key[9], 0x77, 23);
			
			atcac_sw_sha2_256_init(&ctx);
			atcac_sw_sha2_256_update(&ctx, &client_derive_key, sizeof(client_derive_key));
			atcac_sw_sha2_256_finish(&ctx, derive_key);
		}
	}while(0);
	
	return return_code;
}