<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CryptoAuthLib: atca_basic.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CryptoAuthLib
   </div>
   <div id="projectbrief">Atmel CryptoAuthentication Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00061.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">atca_basic.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CryptoAuthLib Basic API methods - a simple crypto authentication api. These methods manage a global ATCADevice object behind the scenes. They also manage the wake/idle state transitions so callers don't need to.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="a00120_source.html">cryptoauthlib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="a00078_source.html">crypto/atca_crypto_sw_sha2.h</a>&quot;</code><br />
</div>
<p><a href="a00061_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">atca_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a427c0d9dc4a1052229c8c75a6d126577"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a427c0d9dc4a1052229c8c75a6d126577">TBD</a>&#160;&#160;&#160;void</td></tr>
<tr class="separator:a427c0d9dc4a1052229c8c75a6d126577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00028.html">atca_sha256_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a></td></tr>
<tr class="separator:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga563f3d7c25ee88ff5b2c988f4eb59bc3">atcab_version</a> (char *verstr)</td></tr>
<tr class="memdesc:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a version string for the CryptoAuthLib release. The format of the version string returned is "yyyymmdd"  <a href="a00225.html#ga563f3d7c25ee88ff5b2c988f4eb59bc3">More...</a><br /></td></tr>
<tr class="separator:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">atcab_init</a> (<a class="el" href="a00046.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">atcab_init is called once for the life of the application and creates a global ATCADevice object used by Basic API. This method builds a global ATCADevice instance behinds the scenes that's used for all Basic API operations  <a href="a00225.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">More...</a><br /></td></tr>
<tr class="separator:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga1cb5f2d8f7796c6d7e93d36a86dc3ce9">atcab_init_device</a> (<a class="el" href="a00222.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> cadevice)</td></tr>
<tr class="memdesc:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">atcab_init_device can be used to initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API.  <a href="a00225.html#ga1cb5f2d8f7796c6d7e93d36a86dc3ce9">More...</a><br /></td></tr>
<tr class="separator:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">atcab_release</a> (void)</td></tr>
<tr class="memdesc:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the global ATCADevice instance. This must be called in order to release or free up the interface.  <a href="a00225.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">More...</a><br /></td></tr>
<tr class="separator:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806030ec6e8b57722eabfd88cb9a548c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00222.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga806030ec6e8b57722eabfd88cb9a548c">atcab_getDevice</a> (void)</td></tr>
<tr class="memdesc:ga806030ec6e8b57722eabfd88cb9a548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a way to get the global device object. Generally for more sophisticated users of atca  <a href="a00225.html#ga806030ec6e8b57722eabfd88cb9a548c">More...</a><br /></td></tr>
<tr class="separator:ga806030ec6e8b57722eabfd88cb9a548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3bc620aedd9322d160eece0d8d20c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gad3bc620aedd9322d160eece0d8d20c82">atcab_wakeup</a> (void)</td></tr>
<tr class="memdesc:gad3bc620aedd9322d160eece0d8d20c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">wakeup the CryptoAuth device  <a href="a00225.html#gad3bc620aedd9322d160eece0d8d20c82">More...</a><br /></td></tr>
<tr class="separator:gad3bc620aedd9322d160eece0d8d20c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">atcab_idle</a> (void)</td></tr>
<tr class="memdesc:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <a href="a00225.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">More...</a><br /></td></tr>
<tr class="separator:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9475e032c388144c5a0df45d1df182a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga9475e032c388144c5a0df45d1df182a5">atcab_sleep</a> (void)</td></tr>
<tr class="memdesc:ga9475e032c388144c5a0df45d1df182a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <a href="a00225.html#ga9475e032c388144c5a0df45d1df182a5">More...</a><br /></td></tr>
<tr class="separator:ga9475e032c388144c5a0df45d1df182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed2c204c79b094e064385c85f3c1b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gabed2c204c79b094e064385c85f3c1b3d">atcab_cfg_discover</a> (<a class="el" href="a00046.html">ATCAIfaceCfg</a> cfgArray[], int <a class="el" href="a00227.html#gaf13cc0c18a825fdc030b007656b14d0b">max</a>)</td></tr>
<tr class="separator:gabed2c204c79b094e064385c85f3c1b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e19ecd60be4c74665d9ec142e460771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga6e19ecd60be4c74665d9ec142e460771">atcab_info</a> (uint8_t *revision)</td></tr>
<tr class="memdesc:ga6e19ecd60be4c74665d9ec142e460771"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the device revision information  <a href="a00225.html#ga6e19ecd60be4c74665d9ec142e460771">More...</a><br /></td></tr>
<tr class="separator:ga6e19ecd60be4c74665d9ec142e460771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b13f56c701eb5564e555923a621ae85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga8b13f56c701eb5564e555923a621ae85">atcab_challenge</a> (const uint8_t *challenge)</td></tr>
<tr class="memdesc:ga8b13f56c701eb5564e555923a621ae85"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a challenge to the device (a pass-through nonce)  <a href="a00225.html#ga8b13f56c701eb5564e555923a621ae85">More...</a><br /></td></tr>
<tr class="separator:ga8b13f56c701eb5564e555923a621ae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga4fc5691ab3a484d7a07cbbc214e6a8f5">atcab_challenge_seed_update</a> (const uint8_t *seed, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a challenge to the device (a seed update nonce)  <a href="a00225.html#ga4fc5691ab3a484d7a07cbbc214e6a8f5">More...</a><br /></td></tr>
<tr class="separator:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaff392b11a0d00fefa2dff30ec7040fc6">atcab_nonce_base</a> (uint8_t mode, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a challenge to the device (a non-seed update nonce)  <a href="a00225.html#gaff392b11a0d00fefa2dff30ec7040fc6">More...</a><br /></td></tr>
<tr class="separator:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gab10c899d3b8cfb1b9ada47f925b8cbce">atcab_nonce</a> (const uint8_t *tempkey)</td></tr>
<tr class="memdesc:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a pass-through Nonce command to initialize TempKey to the specified value.  <a href="a00225.html#gab10c899d3b8cfb1b9ada47f925b8cbce">More...</a><br /></td></tr>
<tr class="separator:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaf162c6327e0cc2e43fc6b483dbc21a32">atcab_nonce_rand</a> (const uint8_t *seed, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize TempKey with a random Nonce.  <a href="a00225.html#gaf162c6327e0cc2e43fc6b483dbc21a32">More...</a><br /></td></tr>
<tr class="separator:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa442396dfbb89e59dfca837b565cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga4fa442396dfbb89e59dfca837b565cec">atcab_random</a> (uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fa442396dfbb89e59dfca837b565cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 32 byte random number from the CryptoAuth device.  <a href="a00225.html#ga4fa442396dfbb89e59dfca837b565cec">More...</a><br /></td></tr>
<tr class="separator:ga4fa442396dfbb89e59dfca837b565cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348574df97ec23b4d3a9c4037ab5024f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga348574df97ec23b4d3a9c4037ab5024f">atcab_is_locked</a> (uint8_t zone, bool *lock_state)</td></tr>
<tr class="memdesc:ga348574df97ec23b4d3a9c4037ab5024f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query to see if the specified zone is locked.  <a href="a00225.html#ga348574df97ec23b4d3a9c4037ab5024f">More...</a><br /></td></tr>
<tr class="separator:ga348574df97ec23b4d3a9c4037ab5024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b4b83b193c05da7d834ed73d077c5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga4b4b83b193c05da7d834ed73d077c5fc">atcab_is_slot_locked</a> (uint8_t slot, bool *lock_state)</td></tr>
<tr class="memdesc:ga4b4b83b193c05da7d834ed73d077c5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query to see if the specified slot is locked.  <a href="a00225.html#ga4b4b83b193c05da7d834ed73d077c5fc">More...</a><br /></td></tr>
<tr class="separator:ga4b4b83b193c05da7d834ed73d077c5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">atcab_get_addr</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint16_t *addr)</td></tr>
<tr class="memdesc:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the address given the zone, slot, block, and offset.  <a href="a00225.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">More...</a><br /></td></tr>
<tr class="separator:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga7a823d2a391bf80ff336eb2ccbd37412">atcab_get_zone_size</a> (uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <a href="a00225.html#ga7a823d2a391bf80ff336eb2ccbd37412">More...</a><br /></td></tr>
<tr class="separator:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">atcab_read_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">read either 4 or 32 bytes of data into given slot  <a href="a00225.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">More...</a><br /></td></tr>
<tr class="separator:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gabf2b29b4d3ae926b63c403d084380dbe">atcab_write</a> (uint8_t zone, uint16_t address, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabf2b29b4d3ae926b63c403d084380dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Write command writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <a href="a00225.html#gabf2b29b4d3ae926b63c403d084380dbe">More...</a><br /></td></tr>
<tr class="separator:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">atcab_write_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write either 4 or 32 bytes of data into a device zone.  <a href="a00225.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">More...</a><br /></td></tr>
<tr class="separator:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a7e195aa3cf28b48de345755feb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gac395a7e195aa3cf28b48de345755feb0">atcab_write_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gac395a7e195aa3cf28b48de345755feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into config, otp, or data zone with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <a href="a00225.html#gac395a7e195aa3cf28b48de345755feb0">More...</a><br /></td></tr>
<tr class="separator:gac395a7e195aa3cf28b48de345755feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef5ecc82d845eaebdf50a58ac489e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gafef5ecc82d845eaebdf50a58ac489e66">atcab_read_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gafef5ecc82d845eaebdf50a58ac489e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from config, otp, or data zone with a given byte offset and length.  <a href="a00225.html#gafef5ecc82d845eaebdf50a58ac489e66">More...</a><br /></td></tr>
<tr class="separator:gafef5ecc82d845eaebdf50a58ac489e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga96c434878e1f435e2cda5b0b5fec444f">atcab_read_serial_number</a> (uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga96c434878e1f435e2cda5b0b5fec444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the serial number of the device  <a href="a00225.html#ga96c434878e1f435e2cda5b0b5fec444f">More...</a><br /></td></tr>
<tr class="separator:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe236622ac65a2ccbf313d4a1971c258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gabe236622ac65a2ccbf313d4a1971c258">atcab_read_pubkey</a> (uint16_t slot8toF, uint8_t *pubkey)</td></tr>
<tr class="memdesc:gabe236622ac65a2ccbf313d4a1971c258"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a pub key from a readable data slot versus atcab_get_pubkey which generates a pubkey from a private key slot  <a href="a00225.html#gabe236622ac65a2ccbf313d4a1971c258">More...</a><br /></td></tr>
<tr class="separator:gabe236622ac65a2ccbf313d4a1971c258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga09f2d9d7d0bfa4badfcea82b9b02f151">atcab_write_pubkey</a> (uint16_t slot8toF, const uint8_t *pubkey)</td></tr>
<tr class="memdesc:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a pub key from to a data slot.  <a href="a00225.html#ga09f2d9d7d0bfa4badfcea82b9b02f151">More...</a><br /></td></tr>
<tr class="separator:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddea9705cb35400bf64c43f8ef3ec368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaddea9705cb35400bf64c43f8ef3ec368">atcab_read_sig</a> (uint8_t slot8toF, uint8_t *sig)</td></tr>
<tr class="memdesc:gaddea9705cb35400bf64c43f8ef3ec368"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a signature found in one of slots 8 through F.  <a href="a00225.html#gaddea9705cb35400bf64c43f8ef3ec368">More...</a><br /></td></tr>
<tr class="separator:gaddea9705cb35400bf64c43f8ef3ec368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f42fd95fbb05881e47b8263b292d037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga9f42fd95fbb05881e47b8263b292d037">atcab_read_ecc_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga9f42fd95fbb05881e47b8263b292d037"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the config zone by block by block for 32 byte read, offset is ignored data receives the contents read from the slot Config zone can be read regardless of it being locked or unlocked  <a href="a00225.html#ga9f42fd95fbb05881e47b8263b292d037">More...</a><br /></td></tr>
<tr class="separator:ga9f42fd95fbb05881e47b8263b292d037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2078e39f168f545b8f4940d3406152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaca2078e39f168f545b8f4940d3406152">atcab_write_ecc_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:gaca2078e39f168f545b8f4940d3406152"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an ECC configuration zone buffer, write its parts to the device's config zone  <a href="a00225.html#gaca2078e39f168f545b8f4940d3406152">More...</a><br /></td></tr>
<tr class="separator:gaca2078e39f168f545b8f4940d3406152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga587123c122c093f445b1a428bffd424b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga587123c122c093f445b1a428bffd424b">atcab_read_sha_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga587123c122c093f445b1a428bffd424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an SHA configuration zone buffer, read its parts from the device's config zone  <a href="a00225.html#ga587123c122c093f445b1a428bffd424b">More...</a><br /></td></tr>
<tr class="separator:ga587123c122c093f445b1a428bffd424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff50af89c352aa2ba09597076f2ca475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaff50af89c352aa2ba09597076f2ca475">atcab_write_sha_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:gaff50af89c352aa2ba09597076f2ca475"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an SHA configuration zone buffer, write its parts to the device's config zone  <a href="a00225.html#gaff50af89c352aa2ba09597076f2ca475">More...</a><br /></td></tr>
<tr class="separator:gaff50af89c352aa2ba09597076f2ca475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">atcab_read_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an SHA configuration zone buffer and dev type, read its parts from the device's config zone  <a href="a00225.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">More...</a><br /></td></tr>
<tr class="separator:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0777a86aa412a97b19cc72a12c171b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga0777a86aa412a97b19cc72a12c171b94">atcab_write_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga0777a86aa412a97b19cc72a12c171b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an SHA configuration zone buffer and dev type, write its parts to the device's config zone  <a href="a00225.html#ga0777a86aa412a97b19cc72a12c171b94">More...</a><br /></td></tr>
<tr class="separator:ga0777a86aa412a97b19cc72a12c171b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gadb91d2c3601b95f0ad413cf84a4dfd87">atcab_cmp_config_zone</a> (uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares all writable bytes in the configuration zone that is passed in to the bytes on the device.  <a href="a00225.html#gadb91d2c3601b95f0ad413cf84a4dfd87">More...</a><br /></td></tr>
<tr class="separator:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dac8b8c0a82dac68da82724129e278d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga8dac8b8c0a82dac68da82724129e278d">atcab_read_enc</a> (uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enckey, const uint16_t enckeyid)</td></tr>
<tr class="memdesc:ga8dac8b8c0a82dac68da82724129e278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32 bytes of data from the given slot. The function returns clear text bytes. Encrypted bytes are read over the wire, then subsequently decrypted Data zone must be locked and the slot configuration must be set to encrypted read for the block to be successfully read.  <a href="a00225.html#ga8dac8b8c0a82dac68da82724129e278d">More...</a><br /></td></tr>
<tr class="separator:ga8dac8b8c0a82dac68da82724129e278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf099dc4245d056db33547fe1d49b541b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaf099dc4245d056db33547fe1d49b541b">atcab_write_enc</a> (uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enckey, const uint16_t enckeyid)</td></tr>
<tr class="memdesc:gaf099dc4245d056db33547fe1d49b541b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32 bytes of data into given slot. The function takes clear text bytes, but encrypts them for writing over the wire Data zone must be locked and the slot configuration must be set to encrypted write for the block to be successfully written.  <a href="a00225.html#gaf099dc4245d056db33547fe1d49b541b">More...</a><br /></td></tr>
<tr class="separator:gaf099dc4245d056db33547fe1d49b541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfb0f4404191874a40464008c5b22de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga5cfb0f4404191874a40464008c5b22de">atcab_lock</a> (uint8_t mode, uint16_t summary, uint8_t *lock_response)</td></tr>
<tr class="memdesc:ga5cfb0f4404191874a40464008c5b22de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <a href="a00225.html#ga5cfb0f4404191874a40464008c5b22de">More...</a><br /></td></tr>
<tr class="separator:ga5cfb0f4404191874a40464008c5b22de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c43e79edd70d87891d676e766244ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga12c43e79edd70d87891d676e766244ec">atcab_lock_config_zone</a> (uint8_t *lock_response)</td></tr>
<tr class="memdesc:ga12c43e79edd70d87891d676e766244ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <a href="a00225.html#ga12c43e79edd70d87891d676e766244ec">More...</a><br /></td></tr>
<tr class="separator:ga12c43e79edd70d87891d676e766244ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad758b97819383fbee19336bf9f9540aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gad758b97819383fbee19336bf9f9540aa">atcab_lock_config_zone_crc</a> (uint16_t crc)</td></tr>
<tr class="memdesc:gad758b97819383fbee19336bf9f9540aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <a href="a00225.html#gad758b97819383fbee19336bf9f9540aa">More...</a><br /></td></tr>
<tr class="separator:gad758b97819383fbee19336bf9f9540aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b30b1b731bed510e36b30fee7fa3ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga07b30b1b731bed510e36b30fee7fa3ae">atcab_lock_data_zone</a> (uint8_t *lock_response)</td></tr>
<tr class="memdesc:ga07b30b1b731bed510e36b30fee7fa3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP).  <a href="a00225.html#ga07b30b1b731bed510e36b30fee7fa3ae">More...</a><br /></td></tr>
<tr class="separator:ga07b30b1b731bed510e36b30fee7fa3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d94968da77056acf8098ef47b8fd53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga2d94968da77056acf8098ef47b8fd53e">atcab_lock_data_zone_crc</a> (uint16_t crc)</td></tr>
<tr class="memdesc:ga2d94968da77056acf8098ef47b8fd53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <a href="a00225.html#ga2d94968da77056acf8098ef47b8fd53e">More...</a><br /></td></tr>
<tr class="separator:ga2d94968da77056acf8098ef47b8fd53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b14188470aca1152fd3dbccb0043549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga7b14188470aca1152fd3dbccb0043549">atcab_lock_data_slot</a> (uint8_t slot, uint8_t *lock_response)</td></tr>
<tr class="memdesc:ga7b14188470aca1152fd3dbccb0043549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1).  <a href="a00225.html#ga7b14188470aca1152fd3dbccb0043549">More...</a><br /></td></tr>
<tr class="separator:ga7b14188470aca1152fd3dbccb0043549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1aabfb0aa6876304c7c096a27902a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gade1aabfb0aa6876304c7c096a27902a5">atcab_priv_write</a> (uint16_t key_id, const uint8_t priv_key[36], uint8_t write_key_slot, const uint8_t write_key[32])</td></tr>
<tr class="memdesc:gade1aabfb0aa6876304c7c096a27902a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a P256 private key in given slot using mac computation  <a href="a00225.html#gade1aabfb0aa6876304c7c096a27902a5">More...</a><br /></td></tr>
<tr class="separator:gade1aabfb0aa6876304c7c096a27902a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaa8b6953ad2c7f749e61566fd38fe6903">atcab_genkey_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can generate a private key, compute a public key, and/or compute a digest of of a public key.  <a href="a00225.html#gaa8b6953ad2c7f749e61566fd38fe6903">More...</a><br /></td></tr>
<tr class="separator:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga617bdbdce7b5736351d93214d44c5b8f">atcab_genkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga617bdbdce7b5736351d93214d44c5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new random private key and return the public key.  <a href="a00225.html#ga617bdbdce7b5736351d93214d44c5b8f">More...</a><br /></td></tr>
<tr class="separator:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2096a4618dd37c48ed48847fe63d844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gad2096a4618dd37c48ed48847fe63d844">atcab_get_pubkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad2096a4618dd37c48ed48847fe63d844"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a public key found in a designated slot. The slot must be configured as a slot with a private key. This method will use GenKey to generate the corresponding public key from the private key in the given slot.  <a href="a00225.html#gad2096a4618dd37c48ed48847fe63d844">More...</a><br /></td></tr>
<tr class="separator:gad2096a4618dd37c48ed48847fe63d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga5c1e598bf3d4d25b522f42d6038a4268">atcab_sign_base</a> (uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Sign command generates a signature using the ECDSA algorithm.  <a href="a00225.html#ga5c1e598bf3d4d25b522f42d6038a4268">More...</a><br /></td></tr>
<tr class="separator:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga69b8282d1b1e0c54b9a7d286fed503b8">atcab_sign</a> (uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a 32-byte message using the private key in the specified slot.  <a href="a00225.html#ga69b8282d1b1e0c54b9a7d286fed503b8">More...</a><br /></td></tr>
<tr class="separator:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga559add3e8b4f85a9d91fc0ed86aefa29">atcab_sign_internal</a> (uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign an internally generated message.  <a href="a00225.html#ga559add3e8b4f85a9d91fc0ed86aefa29">More...</a><br /></td></tr>
<tr class="separator:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023ff586b49807c67f5af587f7480a3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga023ff586b49807c67f5af587f7480a3f">atcab_verify</a> (uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga023ff586b49807c67f5af587f7480a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Verify command takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <a href="a00225.html#ga023ff586b49807c67f5af587f7480a3f">More...</a><br /></td></tr>
<tr class="separator:ga023ff586b49807c67f5af587f7480a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3e18de900ba705192963d08b37f600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga2c3e18de900ba705192963d08b37f600">atcab_verify_extern</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga2c3e18de900ba705192963d08b37f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. Uses the CryptoAuthentication hardware instead of software.  <a href="a00225.html#ga2c3e18de900ba705192963d08b37f600">More...</a><br /></td></tr>
<tr class="separator:ga2c3e18de900ba705192963d08b37f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cc7670847805423ad591985eecd832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gae8cc7670847805423ad591985eecd832">atcab_verify_stored</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gae8cc7670847805423ad591985eecd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a signature and message (ECDSA verify operation) against a public key stored in a specified slot.  <a href="a00225.html#gae8cc7670847805423ad591985eecd832">More...</a><br /></td></tr>
<tr class="separator:gae8cc7670847805423ad591985eecd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gacf9a0c7772ebb65b87c4a4788850702b">atcab_verify_validate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gacf9a0c7772ebb65b87c4a4788850702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a public key stored in a slot.  <a href="a00225.html#gacf9a0c7772ebb65b87c4a4788850702b">More...</a><br /></td></tr>
<tr class="separator:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga9393b545b2fa1fdd539672a0428a30ab">atcab_verify_invalidate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga9393b545b2fa1fdd539672a0428a30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate a public key stored in a slot.  <a href="a00225.html#ga9393b545b2fa1fdd539672a0428a30ab">More...</a><br /></td></tr>
<tr class="separator:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9201defb41eaea6eb37df9a20db791ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga9201defb41eaea6eb37df9a20db791ca">atcab_ecdh</a> (uint16_t key_id, const uint8_t *pubkey, uint8_t *pms)</td></tr>
<tr class="memdesc:ga9201defb41eaea6eb37df9a20db791ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with premaster secret returned in the response.  <a href="a00225.html#ga9201defb41eaea6eb37df9a20db791ca">More...</a><br /></td></tr>
<tr class="separator:ga9201defb41eaea6eb37df9a20db791ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gae2c5daaedc57ca6655e5c23bb2b6f2cd">atcab_ecdh_enc</a> (uint16_t key_id, const uint8_t *pubkey, uint8_t *pms, const uint8_t *enckey, uint16_t enckeyid)</td></tr>
<tr class="memdesc:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with premaster secret read (encrypted) from next slot.  <a href="a00225.html#gae2c5daaedc57ca6655e5c23bb2b6f2cd">More...</a><br /></td></tr>
<tr class="separator:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga70751ea87f2cf913986bc7bca2cc661f">atcab_gendig</a> (uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga70751ea87f2cf913986bc7bca2cc661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <a href="a00225.html#ga70751ea87f2cf913986bc7bca2cc661f">More...</a><br /></td></tr>
<tr class="separator:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga98cb802fbb5d78cd552bb05c21d6c791">atcab_mac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 32 byte MAC from the CryptoAuth device given a key ID and a challenge.  <a href="a00225.html#ga98cb802fbb5d78cd552bb05c21d6c791">More...</a><br /></td></tr>
<tr class="separator:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">atcab_checkmac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <a href="a00225.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">More...</a><br /></td></tr>
<tr class="separator:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga45f1d09a51f7a1f68916536ab5125b9d">atcab_hmac</a> (uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HMAC command computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device. The output of this command is the output of the HMAC algorithm computed over this key and message. If the message includes the serial number of the device, the response is said to be "diversified".  <a href="a00225.html#ga45f1d09a51f7a1f68916536ab5125b9d">More...</a><br /></td></tr>
<tr class="separator:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd8da6a78188668976dcce54f54bbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gaebd8da6a78188668976dcce54f54bbc9">atcab_derivekey</a> (uint8_t random, uint16_t key_id, uint8_t *mac)</td></tr>
<tr class="memdesc:gaebd8da6a78188668976dcce54f54bbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a DeriveKey Command to the device  <a href="a00225.html#gaebd8da6a78188668976dcce54f54bbc9">More...</a><br /></td></tr>
<tr class="separator:gaebd8da6a78188668976dcce54f54bbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98100897f317f28b768a484080056e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga98100897f317f28b768a484080056e7d">atcab_sha_base</a> (uint8_t mode, uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98100897f317f28b768a484080056e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SHA command computes a SHA-256 digest for general purpose use by the system. Any message length can be accommodated. The system is responsible for sending the pad and length bytes with the last block for ATSHA devices.  <a href="a00225.html#ga98100897f317f28b768a484080056e7d">More...</a><br /></td></tr>
<tr class="separator:ga98100897f317f28b768a484080056e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">atcab_sha_start</a> (void)</td></tr>
<tr class="memdesc:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SHA-256 calculation engine.  <a href="a00225.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">More...</a><br /></td></tr>
<tr class="separator:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">atcab_sha_update</a> (const uint8_t *message)</td></tr>
<tr class="memdesc:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the message to be digested.  <a href="a00225.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">More...</a><br /></td></tr>
<tr class="separator:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db86704035048066a370815b657234d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga1db86704035048066a370815b657234d">atcab_sha_end</a> (uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga1db86704035048066a370815b657234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SHA-256 calculation is complete.  <a href="a00225.html#ga1db86704035048066a370815b657234d">More...</a><br /></td></tr>
<tr class="separator:ga1db86704035048066a370815b657234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d269ccdafd08519a899a8aebf53df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga31d269ccdafd08519a899a8aebf53df1">atcab_sha</a> (uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga31d269ccdafd08519a899a8aebf53df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a SHA-256 digest.  <a href="a00225.html#ga31d269ccdafd08519a899a8aebf53df1">More...</a><br /></td></tr>
<tr class="separator:ga31d269ccdafd08519a899a8aebf53df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga416e4aeacf3acc35b1d5b76028c6947d">atcab_updateextra</a> (uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UpdateExtra command is used to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <a href="a00225.html#ga416e4aeacf3acc35b1d5b76028c6947d">More...</a><br /></td></tr>
<tr class="separator:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade49e7746864105730fa7d531645ff62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#gade49e7746864105730fa7d531645ff62">atcab_hw_sha2_256_init</a> (<a class="el" href="a00225.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gade49e7746864105730fa7d531645ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga67f2ce6224651d9cc65e9915e35558bd">atcab_hw_sha2_256_update</a> (<a class="el" href="a00225.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="separator:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a374d0ed07002b4c20eb49592641c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga0a374d0ed07002b4c20eb49592641c95">atcab_hw_sha2_256_finish</a> (<a class="el" href="a00225.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, uint8_t digest[<a class="el" href="a00226.html#ga86364f6d07b86740f3170d9d1ca60641">ATCA_SHA2_256_DIGEST_SIZE</a>])</td></tr>
<tr class="separator:ga0a374d0ed07002b4c20eb49592641c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f26091b8754321ab55440a9e6b01ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html#ga89f26091b8754321ab55440a9e6b01ae">atcab_hw_sha2_256</a> (const uint8_t *data, size_t data_size, uint8_t digest[<a class="el" href="a00226.html#ga86364f6d07b86740f3170d9d1ca60641">ATCA_SHA2_256_DIGEST_SIZE</a>])</td></tr>
<tr class="separator:ga89f26091b8754321ab55440a9e6b01ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CryptoAuthLib Basic API methods - a simple crypto authentication api. These methods manage a global ATCADevice object behind the scenes. They also manage the wake/idle state transitions so callers don't need to. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2015 Atmel Corporation. All rights reserved.</dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a427c0d9dc4a1052229c8c75a6d126577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TBD&#160;&#160;&#160;void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_f987fb6e7cf85d8e48d70ffe78b3ebc1.html">basic</a></li><li class="navelem"><a class="el" href="a00061.html">atca_basic.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
